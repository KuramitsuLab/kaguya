次世代Smartcontractと分散型アプリケーション基盤
ナカモトサトシの論文により、2009年に開発されたBitcoinは通貨・貨幣における革新的な発明だと謳われ、金兌換のような後ろ盾がなく、中央通貨管理局をもたないはじめてのデジタル財産の例です。
(intrinsicvalue)しかし、その壮大なBitcoinの実験における、より特筆すべき重要部は別の所にあります。
それは分散型大衆決定のツールとして、まさにその基礎をなすBlockchainの技術であり、急速に人々の注目を集めつつあります。


一般的に、blockchainテクノロジーを引用しているBitcoinの代替アプリで、blockchain上の電子財産を実装したものとして:

一定取引量のある通貨や金融商品をあらわすもの(coloredcoins)
基礎となる物理デバイスの所有権(smartproperty)
ドメインのような投資対象外の財産(Namecoin)
があり、より複雑なアプリケーションとしては以下のものが挙げられます:

(役人や銀行員に取って代わり)、コーディングであらゆるルールを実装し、個々の電子資産を管理するもの(smartcontracts)
上記のスマートコントラクトをblockchain上で実装したもの(DAO)
Ethereumが提供しようとしているものは、チューリング完全なプログラミング言語の完成品をblockchainに埋め込み提供することにあります。
この言語は、"contract"を生成するために使用され、"contract"とはあらゆる関数をプログラムしたものです。
これにより、ユーザーは上記の全てのシステムを実装することが可能で、われわれがまだ想像すらしていない多くの可能性が、論理を秘めし数行のコードを書き上げるだけで実現できるようになります。


Bitcoinへの導入と既存の概念
歴史
上述の資産登録マシンのような代替アプリや、分散型デジタル通貨の概念が現れ始めたのは、ここ数十年です。
80〜90年代にかけて、DavidChaumの「ブラインディング署名blindingsignature」をよりどころとした匿名のデジタル通貨プロトコルがたくさん開発され、高いプライバシーをもつ通貨を提供しましたが、これらは中央集約型の媒体に依存していたため、広く注目を浴びるには至りませんでした。
1998年に発表された、WeiDaiによるb-moneyが、現行の分散型のコンセンサスと同様のもので、計算問題を解くことによってお金を創造するというアイデアを、はじめて導入した事例となります。
しかし、このプロポーザルの詳細は不十分であったため、実用的な分散型の大衆意思決定を実装することができませんでした。
2005年、HalFinneyが、暗号通貨のコンセプトをつくりあげるために、ABCDHashcashパズル[jp-1]とb-moneyからアイデアをしぼり作られたシステムである"reusableproofsofwork"というコンセプトを発表しましたが、バックエンドに、信用のある計算機を使用しなければならなかったため、真に分散型とは呼べず、再び失敗しました。
2009年のナカモトサトシによる実用的な実装がはじめての分散型の通貨となりました。
これは、昔からあった「公開鍵暗号（所有権を管理)」と大衆意思決定アルゴリズムである「"proofofwork"(誰がコインを所有しているのか追跡)」を結びあわせたものとなります。


proofofworkの背景にある技術は宇宙史に名を刻むほどの飛躍的進歩でありました。
なぜならproofofworkは、同時に二つの難題を解決したのです。


ひとつめは、単純明快で適切な影響力をもつ大衆意思決定のアルゴリズムの提供で、ネットワーク上のノードはBitcoinの帳簿の「一般規則に従う状態更新」ができるようになりました。

ふたつめは、大衆意思決定のプロセスへの自由参加を可能にするメカニズムの提供で、誰が、コンセンサスに影響をもたらすのかということを決める政治的問題を解決したのです。
これは同時にSybilAttack（ひとりでノードを多数生成し多数決的に攻撃する手法）を防ぐことにつながります。

これは次のようにして、参加基準を定式化したということです。


ノードに対し、特定リストにおける唯一性の証明書の提出を要求し、
さらに「大衆意思決定のプロセスにおける単位ノードの重みは、ノードのもつ計算能力に応じて分配する」というエコノミックバリア[jp-2]を採用する
その後、proofofstakeと呼ばれる手法も提案されています。
計算資源ではなく保持している通貨量に比例してノードの重みを計算するというものです。
2つの手法の相対的な利点に関する議論はこの白書の枠を超えてしまいますが、どちらの手法も暗号通貨を支える屋台骨として利用されていることは言及しておいて良いでしょう。


歴史に関しては、Ethereumを創設したVitalikButerinのブログ記事Ethereumpre-historyがあります。
さらなる歴史についてはこちらの記事もあります。


状態遷移システムとしてのBitcoin
statetransition.png

技術的観点から見ると、（本来Bitcoinは、状態を持たない、ただの関数の鎖に過ぎない純粋なものですが、）Bitcoinをはじめとした暗号通貨の帳簿は、全bitcoinの所有状況をあらわす「状態」と、状態と取引(トランザクション、状態遷移関数のこと)から新たな状態を出力する「状態遷移関数」をもった、「状態遷移」のシステムとしてみることができます。
一般的銀行のシステムでは、たとえば「状態」はバランスシートにあたり、「トランザクション」はAからBにXドル移動してくれ、というリクエストにあたり、この状態遷移関数は、XドルだけAの口座の残高を減らし、Bの残高を増やします。
もし、Aの口座の残高がXドルに満たなかった場合には、状態遷移関数はエラーを返します。
これを定式化し、

APPLY(S,TX)->S'orERROR
この銀行システムは以上で定義され、以下はその適用例です。


APPLY({Alice:$50,Bob:$50},"send$20fromAlicetoBob")={Alice:$30,Bob:$70}

APPLY({Alice:$50,Bob:$50},"send$70fromAlicetoBob")=ERROR
Bitcoinにおける「状態state」とは、全コインの集合であり、技術的に説明いたしますと、発行されているコインのうちで「UTXO（未使用の取引出力値）」の全集合となり、各UTXOには、それぞれ「残高」と「所有者」が記録されています。
「所有者」は、基本的に、暗号理論における公開鍵[1]である20バイト(160bit)のアドレスとなります。
「トランザクション」は、状態遷移関数であり、一以上の入力値と一以上の出力値をとります。
各入力値は、「既存のUTXOへの参照」と「所有者のアドレスと関連付けられた秘密鍵による暗号署名」から構成され、各出力値は、「新しく生成されたUTXO」を保持しています。


状態遷移関数APPLY(S,TX)->S'を定義するプログラムの概略は以下となります。
:

各入力TXに対して:
もし、参照先のUTXOが、状態Sに保持されていないならば、エラーを返す。

もし、提供された署名がそのUTXOの所有者のものとマッチしなければ、エラーを返す。

もし、入力用の全UTXOの価値の合計が、出力用の全UTXOの価値の合計より小さければ、エラーを返します。

入力用の全UTXOを取り除き、出力用の全UTXOを加えた新たな状態Sを返します。

ひとつめのステップにおける前半部により、トランザクションの送信者が、存在しないコインを不正に送ることを防止し、後半部により、トランザクションの送信者が、他人のコインを勝手に送ることを防止します。
ふたつめのステップによって、トータルバリューの保存（入力値の総計が出力値の総計と等しい）が執行されます。
これを実用的な支払いに適用するための、プロトコルは以下のようになります。


アリスがボブに11.7BTCを送信したいとします。
まずはじめに、アリスは、利用可能なUTXOを自分の持っているものの中からかき集め、少なくとも総計11.7BTCになるようにします。
アリスのUTXOを集めてちょうど11.7BTCをつくることはできず、6+4+2=12BTCがアリスの得る最小の値です。
そして彼女は、３つの入力値と２つの出力値をもつトランザクションをつくります。
ひとつめの出力値は11.7BTCでボブのアドレスが所有者として記録され、ふたつめの出力値は0.3BTCの"お釣り"がアリス自身を所有者として記録されます。


採掘
block_picture.jpg

もし、アクセス対象として信用取引可能な中央集約型のサービスを使っているのであれば、このシステムの実装は至極簡単なものであったでしょう。
単に上記のプログラムコードを記すのに、中央サーバーのハードディスクを使用し、「状態」を記録・維持すれば済む話であったでしょう。
しかし、わたしたちがBitcoinを用いてやろうとしているのは、分散型通貨システムの構築です。
なので、トランザクションの順番をみんなが合意できることを確約するために、状態遷移システムと大衆意思決定のシステムをくっつけてやらなくてはなりません。
Bitcoinの分散型大衆決定プロセスでは、「ブロック」と呼ばれる「トランザクションを梱包したもの」を作り続けようとする、ネットワーク上のノードが必要です。
ネットワークは、だいたい10分毎にひとつのブロックを生成するように設計されており、各々のブロックは、

「タイムスタンプ」
「ノンス」
「直前のブロックへの参照値」
「（直前のブロック生成後から現在までに遂行された）トランザクションのリスト」
を保持します。
（※ノンス：ブロック生成時にインクリメントされ続ける個体識別ハッシュ値で、マイナーがブロックを掘り当てることを目標にして独自にインクリメントする。
）このブロックが時間発展することによって、Bitcoinの帳簿を最新状態に更新し続ける、永続的かつ恒久的成長をなす"blockchain"（ブロックの鎖）を生成します。


現パラダイム下において、ブロックが有効かどうかをチェックするアルゴリズムは以下となります：

そのブロックが参照する直前のブロックが存在し、それが有効であるかをチェックする。

そのブロックのタイムスタンプが直前のブロック[2]より大きく、かつ２時間後の未来におけるものまでそれにおけるものより小さいかを確認する。

そのブロック上での、proofofworkが有効かチェックする。

直前のブロックの終状態をS[0]とします。

TXをn個のトランザクションからなる「リスト」だとします。
0...n-1における、全てのiに対し、S[i+1]=APPLY(S[i],TX[i])と順番に適用します。
もし、一つでもエラーを返せば、exitし、falseを返します。

trueを返し、このブロックの最後の状態としてS[n]を記録します。

基本的にブロック内の各トランザクションは、トランザクション執行前の過去の状態をもとにして、有効な状態遷移を提供しなければなりません。
「状態」はいかなる点においても、ブロック内に記述されないことに注意してください。
（ブロックは状態遷移関数をつなげ合わせた関数そのものであり、入力値である「状態」については何も書かれていません）；（このアルゴリズムは、「検証ノード」を説明する簡単な抽象例であり、どのブロックの検証においても、開始状態から、全ブロックの全トランザクションを順番に適用することによって、目的となるブロックの示す状態を計算すれば十分となります。
）さらに「採掘者miner」がトランザクションをブロックに取り込む順番がとても重要だということに注意してください。
（もし、A、Bという二つのトランザクションがあって、BはAの生成したUTXO(未使用出力値)を使う場合において、AのあとにBがきているブロックは有効ですが、そうでない場合は無効となってしまいます。
）

他のシステムでは見受けられない仕様として、上述のトランザクションリストは、（どのトランザクションがどこに取り入れられるか、あるいは取り入れられないなど、によって数多の選択肢が考えられますが、）ここで「有効なものを一つ選ぶための選定条件」が"proofofwork"には必要となります。
厳密な定義は、全てのブロックのdouble-SHA256hash値（256bitの数値）が動的に変化するように設計された「目的値target」より小さくなること、であり、目的値は、これを執筆している当時では、約2187でした。
これは、ブロック生成を計算科学上"難しく"する為であり、その結果、SybilAttack（ひとりでノードを多数生成し多数決的に攻撃する手法）による攻撃者が自身の好きなように全blockchainを改竄してしまうことを防止いたします。
SHA256（エスエイチエーにごろ）は、完全に予測不可能な擬似乱数関数として設計されており、有効なブロックをつくる唯一の方法は、単にノンスをインクリメントしてはその新しいhash値が適合するかを確かめるという、試行錯誤を繰り返すしかありません。


現在における~2187の「目的値」では、ネットワークは~269回の試行錯誤をしてやっとブロックを見つけることができます。
ふつう、目的値は、ネットワーク上で2016ブロック生成される毎に再設定され、ネットワーク上にあるノードによるブロックの発掘が平均して10分毎に生じるよう調整されます。
採掘者に競わせてこの計算をさせるための設定として、ブロックを採掘したものは、どこからともなく湧いた自分への25BTCの報酬を、トランザクションとして最後に付け加えます。
さらに、全入力値が全出力値よりも大きいような全てのトランザクションにおける、その差額は「取引手数料transactionfee」として、採掘者のもとへ行く仕組みです。
ところで、これはBitcoinが発行される唯一のメカニズムとなります。
つまり、初期状態においては、Bitcoinは皆無であったわけです。


マイニングの目的をより深く理解するために、悪意ある攻撃者のおこす事件によって何がおこるのかを見ていきましょう。
Bitcoinの基礎となる暗号理論はセキュリティの高いものと知られているので、攻撃者の狙い目としては、直接、暗号理論で守られていない部分:トランザクションの順序となるでしょう。


攻撃者の戦略は簡単なものです:

ある商売人に100BTCをある商品の購入代金として送る(瞬間的な発送ができるデジタル商品が好まれます)
商品の到着を待つ
自分自身に100BTCを送る別のトランザクションを生成する
ネットワークが、後に作った方のトランザクションの順番が最初にくるようなブロックを、承認するように試みる
一度、ステップ1が履行されると数分後に採掘者がトランザクションをブロックに含めます。
ブロック番号は270000とします。
一時間後、５個以上のブロックが、そのブロックの後ろに追加され、この５つのブロックが、間接的にそのトランザクションを参照しているため、トランザクションは「承認confirming」されたということになります。
この時点で、商売人は、支払いが確定したものとみなし、商品を発送します。
ここではデジタル商品を考え、商品がすぐに届くこととします。
さていま、攻撃者が、別のトランザクションを作成し、自分宛に100BTCを送るものとします。
攻撃者が、もし単にそれを野に放っただけならば、そのトランザクションは受理されないでしょう。
法の番人である採掘者は、APPLY(S,TX)を実行するとき、TXが、使用済みUTXOを使用しようとしていることに気づくでしょう。
なので代わりに、攻撃者はブロックチェーンを分岐させ、親として同じ269999番目のブロックを参照する270000番目の新しいバージョンのブロックを生成します。
ここでは、もとのブロックに含まれていたトランザクションは含まれず、新しいトランザクションが追加されていくこととなります。
ブロックのデータの中身が違うので、攻撃者はproofofworkをやり直す必要があります。
さらに、攻撃者の新しいブロック270000では、異なるハッシュ値を生成するので、もとのブロックチェーン上のブロック270001~270005は、このブロックを参照しません。
このように、もとのブロックチェーンと攻撃者のチェーンは完全に分断されるのです。
このとき適用されるルールは次のようになります。
ブロックチェーンの分岐時は、一番長いブロックチェーンが"信用"あるものとして選択されます。
なので、攻撃者が新しい270000のブロックチェーン上で採掘し続ける傍で、このシステムの法の番人である採掘者達はもとの270005のブロックチェーンを採掘し続けることになります。
攻撃者が、自分のブロックチェーンを最長にするためには、ネットワーク上の残りのすべてのノードの総和より、高い計算能力を誇る必要があり、これを「51%攻撃」と呼びます。


マークル木
SPVinbitcoin

左　:　分岐の正当性の証明には、少しのノードを与えてやるだけでよい

右　:　どの部分にいかなる変化を付与しても、鎖の上方で必ず不一致を生む

Bitcoinの重要なスケーラビリティ特性は「ブロックは多層データ構造で保管される」ということです。
ブロックの「ハッシュ値」とは実は、ブロックヘッダ（先頭部）のハッシュ値に過ぎず、これは約200byteのデータであり、

タイムスタンプ
ノンス
直前のブロックのハッシュ値
マークル木（ブロック内の全トランザクションを保持するデータ構造）のルート（根の元となる部分）のハッシュ値
を保持します。
マークル木は、バイナリ木のひとつで、以下の三つから構成されます。


基礎データを保持する木構造の最下層の「葉（リーフノード）」の集合
二つの子ノードのハッシュ値である「枝（中間ノード）」の集合
唯一の「根（ルートノード）」（二つの子ノードのハッシュ値で"頂上"にくるもの）
マークル木は、ブロック中のデータをバラバラに運搬するためにつくられました。
ノードは、ひとつのソース（ネットワーク上の自身とは別のノード）からブロックヘッダだけを、別のソースから、必要なトランザクションに関連する小さな部分木を、ダウンロードすることができ、それでもなお全データの整合性を保証できるのです。
これがうまく動作する所以は、ハッシュ値が上に伝播していくところです。
：もし悪意のあるユーザーが偽物のトランザクションをマークル木の底のノードと取り替えようとすると、この変化はその親のノードを変化させ、繰り返し伝播することで最終的にルートの値を変化させます。
つまり、ブロックのハッシュ値が変化し、マークル木のプロトコルにより、結果として、全く別のブロックとして記録され、このブロックは十中八九proofofworkが無効となります。


マークル木のプロトコルは、言うまでもなく長期にわたるアプリケーションの維持のために必要です。
Bitcoinネットワークにおける「完全ノード、フルノード」とは、「全ブロックの全トランザクションを保管・処理するノード」のことで、2014年4月の時点で15GBの容量をとり、ひと月あたり１GB以上の速さで増え続けています。
現在、これはデスクトップコンピュータ上で目視できますが、携帯電話では確認できません。
容量的な観点から、後々の未来、完全ノードに参加できるのは、ビジネスや趣味の範疇に限られてくるでしょう。
「SPV（簡素な支払検証）」として知られるプロトコルにより、「完全ノード」とは別タイプのノードが開発されました。
「軽量ノード、ライトノード」と呼ばれ、このノードは、ブロックヘッダをダウンロードし、ブロックヘッダでproofofworkを検証し、そして自身に関係のあるトランザクションの「枝、ブランチ」だけをダウンロードします。
軽量ノードは、セキュリティを強く保ったまま、トランザクション履歴や残高を、状態遷移関数により決定することができるというのに、全ブロックチェーンの小さな部分木をダウンロードすればよい、というものなのです。


Blockchainを用いた代替アプリケーション
基礎技術であるblockchainの他コンセプトへの応用は、これもまた、長い歴史があります。
2005年　NickSzaboが"securepropertytitleswithownerauthority（自己の権威によるセキュアな財産の獲得）"というコンセプトを発表しました。
この論文は、複製データベースの技術の進歩により、いかにしてblockchain基調のシステムが、土地所有の登記の保管を可能にするのかを記述し、「開拓homesteading」「不法占有adversepossesion」「ジョージの土地課税Georgianlandtax」といったコンセプトを含む枠組みを、苦労して築き上げました。
しかし、残念ながら、当時利用できる、効果的な複製データシステムがなかったため、プロトコルが実際に実装されることはありませでした。
とは言うものの、2009年にBitcoinの分散型コンセンサスが一度開発されてからは、急速に代替アプリが出現し始めました。


Namecoin-2010年に作られたNamecoinは「分散型名前登録データベース」と表現されます。
TorやBitcoin,BitMessageのような分散型プロトコルでは、個体識別にアカウントが必要で、そのため他人による干渉が可能ですが、どのようにしても利用可能な識別子は、1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWyのような擬似乱数となります。
できれば"ジョージ"のような名前をつけることができたらいいな、と考えるでしょう。
しかしながら、問題なのは"ジョージ"という名前を誰でも、同じプロセスをたどることで登録でき、"ジョージ"として振舞えるのです。
唯一の解決策は「first-to-fileパラダイム」を用いることです。
これは、最初（first）の登録者は登録（file）に成功し、二番目以降では失敗するというものです。
この問題はBitcoinの大衆意思決定のプロトコルに完全に合致し、Namecoinは一早くにこの考えを使って名前登録のシステムを実装し、見事に成功しました。


Coloredcoins-coloredcoinsの目的は、Bitcoinのblockchain上に「自身で作ったデジタル通貨」や、通貨の重要な性質である少額使用の例としてユニットを採用した「デジタルトークン」を、構築できるプロトコルを提供することです。
coloredcoinsのプロトコルでは、特定のBitcoinUTXOに「色」を設定することで、新しい通貨を"発行"します。
プロトコルは、coleredcoinsを生成するトランザクションの入力値に「色」が付いていれば、他のUTXOも同じ「色」であるものと再帰的に定義します。
（様々な「色」の入力が混じった場合は、特別なルールが適用されます。
）このことで、ユーザーは特別な色のUTXOだけを保持する財布を維持し、ほとんどBitcoinと同じように周囲に対し送金することが可能で、受け取ったUTXOの色を特定するにはblockchainを遡ります。


Metacoins-metacoinsの背景となる思想は「Bitcoinを土台として、その上で動作するプロトコルをもつ」であり、metacoinsのトランザクションの保管に、Bitcoinのトランザクションを使用しますが、Bitcoinとは別の状態遷移関数APPLY'を保持します。
metacoinsのプロトコルは、無効なmetacoinsトランザクションがBitcoinblockchain上にでてくることを防止するために、規則「ifAPPLY'(S,TX)returnsanerror,theprotocoldefaultsto`APPLY'(S,TX)=S」を加えます。
metacoinsは、任意の独自暗号通貨をつくるための簡単なメカニズムを提供しており、Bitcoin自体のシステム内部においては表面化することのない先進的な独自機能を持たせることができます。
採掘とネットワークのシステムといった複雑な部分がすでにBitcoinプロトコルによって処理されているので、開発コストはとても低く済みます。
metacoinsはいくつかの金融契約や名前登録や分散型両替所を実装するのに使われています。


一般的に言って、大衆意思決定プロトコルを構築する方法は二種類あります。
「独自のネットワークをつくる方法」と「Bitcoinを土台とする方法」です。
前者の方法は、namecoinでは適度な成功を収めたものの、実装するのが大変です。
と言いますのは、独自の実装はそれぞれにおいて、独自のブロックチェーンをつくる必要があり、同様に、それに必要な状態遷移とネットワークを構成するコードのあらゆるビルド・アンド・テストが必要となります。
さらに、そうしてできた分散型大衆決定のアプリケーションの数々の集合は、採掘（power）と検証（law）の分散を招き、仮にアプリケーションの中では多数派であったとしても、規模が小さすぎて自分のブロックチェーンを公正なものとすることができない、といった事態を招きます。
そして次のことを認識するに至りました。
大きな種類の分散型アプリがあったとして、とりわけ分散型自動組織では、それらはお互いに手を取り合わなければなりません。


一方で、「Bitcoinを土台とする方法」では、BitcoinのSPV特性を継承しないという欠陥があります。
SPVはBitcoinでは動作しますが、それはblockchainにおけるブロックの「深さ」がその正当性を代弁するためです。
一度、トランザクションの祖先が深いところへ行ってしまえば、そのトランザクションは、現在の「状態」を構成する正当な状態遷移関数であると、安心して言うことができます。
一方、metaプロトコルでは、そのコンテクスト内でトランザクションが無効であっても、Bitcoinのblockchainにおいて、それが組み込まれることを阻止する方法はありません。
（BitcoinのコンテクストとMetaプロトコルのコンテクストは異なります。
）このように、もし、完全にセキュアなSPVmetaプロトコルの実装が存在したならば、あるトランザクションが有効かどうかを判定するために、Bitcoinのblockchainの一番最初まで全過程を遡ってスキャンする必要があるでしょう。
現在、metaプロトコルの軽量実装は、データを提供する信用機関としてのサーバーに依存しており、言うまでもなく、とりわけ暗号通貨の当初の目的の一つが「信用機関の必要性の消去」であるような状況下では、最良の結果であるとは到底言えません。


スクリプリト言語による記述
たとえまったく拡張をせずとも、実は、Bitcoinプロトコルは「smartcontracts」コンセプトの機能的に弱いバージョンを簡単に実装したものなのです。
BitcoinのUTXOは、「公開鍵」に保持されるだけでなく、簡素なスタック・ベース・プログラミング言語で表現される少し複雑な「スクリプト」が、保持することもできます。
このパラダイムの下で、トランザクションが、スクリプト保持のUTXOを入力値とすれば、スクリプトの記述内容を満たすデータが出力値となるように、トランザクションの記述がされなければなりません。
さらには、基本的な公開鍵保有メカニズム（その公開鍵を使用したトランザクションがブロック内にあるかどうかを検証するメカニズム）でさえ、スクリプトを通して実装されています。
そのスクリプトは、ブロック生成の証である楕円曲線署名を入力値として受け取り、トランザクションとそのUTXOを所有するアドレス（公開鍵）に対してその署名を検証し、検証が成功すれば1を返し、そうでなければ0を返します。
他にも、より複雑なスクリプトが様々な使用場面のために存在します。
例えば、トランザクション検証の際、与えられた三つの鍵の組のうち二つの署名を必要とするスクリプト（マルチシグmultisig）や、企業アカウントや、セキュリティの高い口座アカウント、商売におけるエスクローが必要な状況に役立つ初期設定を構築することができます。
スクリプトは、計算問題の答えに対する懸賞金の支払いにおいても使用され、「もしあなたがこの額のDogecoinのトランザクションを送信したというSPVproofを提供できるならば、このBitcoinはあなたのものだ」といったようなことを記述したスクリプトでさえ構築可能です。
そして基本的には、分散型のクロス暗号通貨の取引が可能です。


しかしながら、Bitcoinに実装されたようなスクリプト言語にはいくつかの重要な制限があります。
：

チューリング完全性の欠如-つまるところ、Bitcoinスクリプト言語は計算理論の大部分をサポートしていますが、ほぼ全てという訳ではありません。
サポートしていない代表的なものとしてループが挙げられます。
これは、トランザクションの検証中に無限ループに陥る事を避けるために除外されました。
理論的には、プログラマにとってはこれは簡単に克服できる障害で、if文と一緒に基本コードを繰り返せば、あらゆるループを模倣できますが、スクリプトを記録する（ブロックチェーン上の）スペースを極めて非効率に使用することになります。
たとえば、楕円曲線署名の代替アルゴリズムをスクリプト上に実装したならば、全く同じである掛け算の命令セットが256回個別に記述されてしまいます。


値が定まらない問題-UTXOを保持するスクリプトが、取引量をきめ細やかに管理する方法はありません。
たとえば、もしも、神のみぞ知るような内容の契約の大きな取引だっとしたら、それは価格操作等の生じうるヘッジング契約となってしまうでしょう。
それは次のような状況です。
AとBがそれぞれ$1000相当のBTCをスクリプトに提出し、スクリプトが30日後に$1000相当のBTCをAに残りをBに送るものとします。
30日後の1BTCのUSドル価格を決定するのには神託が必要となり、しかし、これは、現在利用可能な完全な中央集約型の方法でさえ、信用とインフラの観点で大きな改良が必要となります。
しかしながら、UTXOは使うか使わないかの２択なので、神託が提示しうるすべての価格をUTXOで表すには、2進数計算しかなく、そのため極めて非効率なUTXOの"ハッキング"が必要で、様々な残高のUTXOを用意する必要があります。
たとえば、2kの値をもつUTXOをk=0,...,30まで31個つくれば良いでしょう。


状態の欠如-UTXOは使うか、使われないかのどちらかを必ず決定してやらなければなりません。
このため、内部に「状態」を保持する多層形式の契約やスクリプトを記述することができません。
このことにより、多分岐選択可能な契約や、分散型取引のオファー、２段階の暗号理論による決定プロトコル（セキュリティの高い計算問題の賞金を与える場合に必要です）をつくるのはとても困難となってしまいます。
さらに、UTXOは単純な一度きりの契約をつくることにしか使用できず、分散型組織のような、より複雑な「状態」を保持する契約を記述できず、metaプロトコルの実装を困難なものとします。
また、値の定まらない2進数状態では、「引き出し制限」が不可能となります。
これは重要なアプリケーションであり、大きな弊害であると言えるでしょう。


Blockchainが見えない問題-UTXOは、ノンス、タイムスタンプ、直前のブロックのハッシュといったblockchainのデータに対して盲目です。
このことにより、スクリプト言語が、ランダム性の観点で潜在的価値のあるソースを参照するのを防いでしまい、ギャンブル・アプリケーションや他のカテゴリのいくつかを、厳しく制限してしまうことになります。


このように、暗号通貨の上に進化型のアプリケーションを構築する方法を３つ見てきました。

ひとつめは、新しいblockchainをBitcoinを土台とした上につくり、スクリプト言語を使用し、metaプロトコルを実装する方法です。
ふたつめは、新しいblockchainをつくる方法で、その性質を決定するのに無限の自由が得られますが、開発時間に関するコスト問題、スタートアップに関する問題とセキュリティー面の問題も同様に得られます。
みっつめは、Bitcoinのスクリプト言語を使用する方法で、開発や一般化は簡単ですが、可能性が限られてくること、metaプロトコルの実装は簡単ですが、スケーラビリティの欠点に悩むことになります。


Ethereumでは、われわれは、代替となる骨格を築き上げ、簡単な開発であっても、大きな成果物が得られ、スマフォのようなライト・クライアントのもつ財産に対しても強固なものを提供し、同時に、アプリケーションが経済環境とblockchainセキュリティとを共有できるものを提供することを意図しています。


Ethereum
Ethereumの目的は、分散型アプリケーションのための代替プロトコルを創造し、大規模な分散型アプリケーションにとって、われわれが非常に役立つだろうと信じるところの、数々の修正を加え提供することであります。
ここにおいて、アプリの高速開発にかかる時間、小規模かつ滅多に使われないアプリに対するセキュリティ、他アプリ間の効率のよい相互作用を可能とすること、が重要視されます。
Ethereumは、基本的に究極の抽象基盤層となるものの構築により、以上の目的を果たします。
究極の抽象基盤層とは、埋め込み型チューリング完全なプログラム言語を伴うblockchainであり、これにより、所有・トランザクションの形式・状態遷移関数に関する、任意の独自規則を創造することのできる機能を備えたsmartcontractsと分散型アプリをだれでも記述することができます。
Namecoinの骨格だけを抜き出した実装は、二行のコードで記述できます。
通貨や評判を管理するシステムは２０行以下で構築可能です。
「Smartcontracts」と呼ばれる暗号理論で実装された「箱」は、値を保持し、ある条件が整った時にだけ、解錠できます。
この　smartcontractsはEthereumプラットフォーム上に構築可能であり、チューリング完全性、値が定まる仕様、状態の保持およびblockchainへの参照が可能となるところから、Bitcoinスクリプトにはない、広大かつより強力なプラットフォームとなります。


Ethereumアカウント
Ethereumでは、「状態」は、「アカウント」と呼ばれるオブジェクトから作り上げられ、各「アカウント」は、20byteのアドレスと、アカウント間における値や情報の直接的やりとりである状態遷移を保持します。
Ethereumアカウントは４つのフィールドを含みます。


nonce、各トランザクションの処理が一度きりであることを確約するためのカウンター
アカウントの現在のetherbalance
アカウントのcontractcode（もし存在すれば）
アカウントのstorage（デフォルトは空）
Etherは、Ethereumにおける主要な内部暗号燃料であり、トランザクション手数料を支払うために使用されます。
一般的に、アカウントには二つの種類があります。
秘密鍵により管理されるEOA(externallyownedaccounts)と自身のコントラクトコードにより管理されるcontract(contractaccount)です。
EOAはコードを持たず、EOAからトランザクションを生成し署名することによってメッセージを送ることができます。
contractでは、メッセージを受信した時はいつも保持コードをアクティベートし、内部ストレージを読み書き可能にし、メッセージを送信するもしくは新しいコントラクトを作る、といった内容のことが順番に実行されます。


Ethereumにおけるcontractは履行されるべきあるいは一緒にコンパイルされるべきものというよりかはむしろ、Ethereum実行環境を職場とする「自動金融エージェント」といったものに似ており、メッセージやトランザクションによって起動されたときには、いつもある特定のコードを実行し、自身のether残高と、なんども使う変数を把握するのに必要なkey/valueストレージを直接管理する権限を持っている、ということに注意してください。


メッセージとトランザクション
Ethereumにおいて、「トランザクション」は、EOAから送られたメッセージを貯蔵する署名付データパッケージを参照するために使用されます。
トランザクションは、以下を含みます。


メッセージの受領人
送信者を特定する署名
送信者から受領人へ送られるetherの量
オプショナルデータフィールド（署名付きデータパッケージ）
STARTGAS値：トランザクションの実行にかかる計算のステップ数の最大値
GASPRICE値：送信者が支払う、１計算ステップあたりの手数料
最初の３つは、どんな暗号通貨にもある標準的な、トランザクションの「フィールド」です。
４つ目のデータフィールドは、デフォルトでは関数を持ちません。
しかし、Ethereum仮想マシンは、contractが使用するopcodeを保持する必要があり、その際このデータフィールドが使用されます。
opcodeとは、「contractがデータにアクセスするのに使用するopcode（オペレーションコード）」です。
もし、contractがblockchain上のドメイン登録サービスとして機能しているならば、contractは投げられたデータをふたつの「フィールド」を保持するものとして解釈したがることでありましょう。
ひとつめのフィールドは、登録するドメインで、ふたつめのフィールドはIPアドレスです。
コントラクトは、opcodeによって、メッセージに含まれるこれらの値を読み込むことで、適切にストレージの中に配置することが可能となるわけです。


STARTGASとGASPRICEのフィールドはEthereumサービスに対するモデル拒否運動を封じ込める狙いがあります。
偶発的あるいは故意による無限ループや他の計算理論的に無駄なコードの消費を避けるために、各トランザクションにはそれらが実行するコードの計算ステップ数の上限を設ける必要があります。
計算の基本ユニットは「gas」と呼びます。
たいてい、１計算ステップは1gasを消費します。
しかし、幾つかの命令では、計算量的に見てより高価であるため、少しおおきなgasの量が必要とされます。
また、状態の一部として保持しなければならないデータ量が増えたりします。
トランザクションにデータを埋め込む際には、1byte毎に5gasの「手数料」もかかります。
「手数料」システムの意図するところは、攻撃者に対し、計算資源や帯域、ストレージを含めた、彼らが消費する全リソースの量に比例した支払いを強要するためです。
このようにして、ネットワークが消費するどんなリソースにも、それが大量消費とつながるような状況を生み出す、すべてのトランザクションに対して、消費量の増加に比例したgasの支払いを強要することとなります。


Messages
contractは他のcontractに対して「メッセージ」を送信することが可能です。
「メッセージ」はネットワークに対して配信されることがなく、Ethereum実行環境内でのみ存在します。
メッセージは以下を含みます。


メッセージの送信者(implicit)
メッセージの受信者
メッセージと一緒に送信されるetherの量
オプショナルデータフィールド
STARTGAS値
基本的には「メッセージ」はトランザクションのようなものですが、contractにより生成され、外部での動作はしない、という点で異なります。
メッセージはcontractがCALLopcodeを実行している時に生成され、このopcodeは「メッセージ」を生成し、実行します。
トランザクションのように、メッセージは、そこに記述されたコードを実行する受信者のアカウントへと導かれます。
このようにして、contractはEOAのやり方と全く同じ方法で、他のcontractと関係性をもつことができます。


ただし、以下のことに注意してください。
トランザクションやコントラクトによって署名されたgasの許容値は、そのトランザクションとトランザクション配下の実行ステップにおいて消費されるgasの総量に適用されます。
たとえば、もし、外部管理者であるAがBに対し、1000gasと一緒にトランザクションを送信し、Bは、Cにメッセージを送信する前に600gasを消費し、Cの内部実行として戻り値を返すまでに300gasが消費されたとすると、Bは、「ガス欠」とならないためには、もう100gasを使用することが可能です。
（ガス欠となってしまうとエラーを返し、トランザクションは実行されません。
）

Ethereumの状態遷移関数
ethertransition.png

Ethereumの状態遷移関数,APPLY(S,TX)->S'は次のように定義できます:

トランンザクションが「well-formed」であるか（例えば、値が正しい数値であるか）チェックし、署名が有効であれば、ノンスが送信者のアカウントのものと合致するかチェックします。
もし、そうでなければ、エラーを返します。

トランザクションの手数料をSTARTGAS*GASPRICEとして計算し、署名から送信アドレスを決定します。
送信者のアカウントの残高から手数料を差し引き、送信者のノンスを次の値へとインクリメントします。
もし、残高不足であれば、エラーを返します。

GAS=STARTGASとして、GAS値を初期化し、トランザクションにおけるbyteデータ量のぶんだけbyteあたり一定量のgasを支払います。

送信者のアカウントから受信者のアカウントにトランザクションの値を転送します。
もし、受信者のアカウントが存在しないものであったならば、あたらしくつくります。
もし、受信者のアカウントがcontractであれば、すべての実行が完了するか、あるいはガス欠になるまでcontractのコードを実行します。

もし、送信者が十分なお金を持っていなかったり、ガス欠のために、値の転送が失敗した場合には、手数料の支払いを除いて、全状態を元に戻し、手数料はマイナーのアカウントに加えます。

そうでなければ、余った全てのgasを全て送信者に返し、消費したgasは採掘者に支払われる手数料として送信します。

たとえば、contractコードが以下であるような場合を考えましょう。


if!self.storage[calldataload(0)]:
self.storage[calldataload(0)]=calldataload(32)
実際は、contractコードは低級EVM言語（アセンブラ）であることに注意してください。
このコードはEthereumにおける高級言語であるひとつであるSerpent言語で書かれており、コードを確約したものにするために、低級EVMコードへコンパイルすることが可能です。
さらに次に記す状況を想定しましょう。
このcontractのストレージは空の状態から始まり、

10etherの値と、
0.001ether/gasのgaspriceで2000gas、そして
64バイトのデータ（0-31バイトが数字2を表し、32~63バイト番地がCHARLIEというstringを表しているものとします。
）
の３つが、トランザクションとともに送信されるものとします。
この場合、状態遷移関数のプロセスは以下のようになります。


トランザクションが有効かつwell-formedであるか確認する。

トランザクション送信者が、最低限2000*0.001=2etherを所持しているか確認する。
もし、所持していれば、2etherを送信者のアカウントから差し引く。

gasの量をgas=2000;として初期化します。
トランザクションのバイト長が170byteであるとすると、byteあたりの手数料が5であったことから、850を差し引くことなり、1150gasが残ります。

送信者のアカウントから10etherを差し引き、それを送信先であるcontractアカウントに加えます。

コードを走らせます。
今回はとてもシンプルです。
まずcontractは自身のストレージにおける2番目の項目が使われているか確認し、未使用であることを確認し、ストレージの2番地にCHARLIEという値をセットします。

この操作で、187gasを消費するとしましょう、すると残りのgasは1150-187=963となります。


963*0.001=0.963etherを送信者のアカウントに返金し、結果として出てきた「状態」を返します。

もしも、トランザクションの受信側にcontractがなかったら、当該トランザクションにおける全手数料は、たんに、トランザクションのバイト長に与えられたGASPRICEの値をかけたものとなり、トランザクションと一緒に送られたデータは全く関係のないものとなってしまうでしょう。


Notethatmessagesworkequivalentlytotransactionsintermsofreverts:もしメッセージがgasを使い果たしてしまったらば、そのメッセージあるいはそのメッセージが引き金となるすべての実行処理がもとにもどされてしまいますが、その「親」の実行に関しては、やり直しになる必要がありません。
これは、contractが他のcontractを呼ぶことに関して「安全」であることを意味し、これは、AがGgasもってBを呼び出すと、Aによる実行はたかだかGgas分であることが保証されている、と捉えることができます。


最後に、contractを生成するopcodeであるCREATEがあることに注意してください。
その実行メカニズムは一般的に言ってCALLに似ていますが、実行結果があたらしく作られたコントラクトのコードを返すという点を除いて同じになります。


補足：contractが実際に信用あるものとして、機能するかどうかについてですが、例として２人間の賭博をあげますと、二人のお金を預けることになるコントラクトはきちんと仕事をするという保証が必要です。
片一方が作成し、騙し取るということが可能に思われます。
しかし、これは簡単に解決できます。
片方により作成されたコントラクトの公開鍵はわかっているので、そのコードが実行する内容は明るみにでており、エミュレーターを使って、きちんと動作することを確認することで、簡単にコントラクトの安全性を逐一確認することができます。


コード実行
Ethereumのcontractコードは低級スタック・ベース・バイトコード言語で書かれており、「Ethereum仮想マシンコード」や「EVMcode」などと呼ばれております。
そのコードは一連のbyte列から構成されており、各byteはひとつの命令を表しております。
一般的に、コード実行とは、プログラムカウンターが現在示すところの命令を実行してはプログラムカウンターを１つインクリメントする繰り返しにより構成される、無限ループであり、エラーやSTOPあるいはRETURNといった命令が検出されるまで終わることがありません。


EVMにおける命令はデータを貯蔵するために必要な三種類のスペースにアクセスします。


stack,後入れ先出しのコンテナで、pushとpopという二つの命令により値を出し入れします。

Memory,無限拡張および無限展開可能なバイト配列
storage,contractが保持する長期保存用ストレージで、Key/valueの貯蔵庫。
スタックやメモリでは計算実行後毎にリセットされるのに対し、storageでは長期間、値が保持される。

コードも、受信したメッセージにおける値・送信者・データにアクセス可能です。
またブロックヘッダのデータにも同様にアクセスできます。
コードは出力としてbyte配列のデータを戻り値として返すことも出来ます。


EVMコードにおける、形だけの実装が施された実行モデルは、驚くほどシンプルです。
Ethereum仮想マシンが動作しているとき、ネットワーク全体における、全仮想マシン計算状態は次のタプルにより決定されます。
(block_state,transaction,message,code,memory,stack,pc,gas)ここで、block_stateは、全アカウントを保持し、残高やストレージといったデータをひきこんだ「globalな状態」を表します。
実行の開始時毎に、「命令」は、変数pc番目のbyteコードを取ってきます。
pc>=len(code)の条件下では0となります。
各命令はタプルに対して、どのように影響するのかという点に関して、独自の定義があります。
例えば、ADDはスタックから、二つアイテムを引き出し(pop)、その合計をまたスタックへ押し込めます(push)。
SSTOREは上部からふたつのアイテムをpopの上、二つ目のアイテムをcontractのストレージにおける、一つ目のアイテムが示す番地に格納します。
即時コンパイルによるEVMマシン実行最適化の方法はたくさんあるにもかかわらず、Ethereumは基本的に、実装すると数百行ほどのbyteコードスペースを費やします。


Blockchainと採掘
apply_block_diagram.png

Ethereumのblockchainは多くの点でBitcoinのそれと似ていますが、いくつか違う点があります。
blockchainのアーキテクチャに関するEthereumとBitcoinの違いは、次のようになります。
Bitcoinとは違いEthereumのブロックはトランザクションのリストとブロック生成時点の状態のコピーを内部に保持しています。
脇道にそれますが、ブロック番号とdifficultyという、べつの二つの値もブロックに貯蔵されます。
Ethereumにおける基本的な、ブロック有効化アルゴリズムは以下となります。


ブロックの参照する直前のブロックが存在し、それが有効であるかをチェックします。

タイムスタンプが、直前のにおけるそれよりも値が大きく、15分さきの未来まで後出のものより値が小さいことを確認します。

ブロック番号、難易度、トランザクションのルート、Uncleのルートおよびガスの上限（様々な、低級Ethereumの仕様概念）が有効であるか確認します。

ブロックの有効証であるproofofworkが有効であるか確認します。

直前のブロックの最後の状態をS[0]とする。

TXをトランザクション・リストとし、n個のトランザクションを含むものとする。
0...n-1までの全ての数に対し、S[i+1]=APPLY(S[i],TX[i])とする。
もし、アプリケーション群のどれか一つでもエラーを返したり、ブロックで消費される全gas量がこの段階でGASLIMITを超過していたりすると、エラーを返します。

S[N]をS_FINALとしますが、採掘者へのブロック採掘に対する報酬も加えます。

状態S_FINALのマークル木のルートがブロックヘッダにおいて与えられる最終状態のルートと一致するか確かめます。
もしそうであれば、ブロックは有効で、そうでなければ、ブロックは無効です。

さっと目を通しただけでは、このアプローチはとても非効率に思うかもしれません。
なぜならば、このやり方では、各ブロックで全ネットワークの状態を保存する必要があるからです。
しかし、現実的には、Etherumの効率は、Bitcoinのそれと比べなければなりません。
というのは、ここで保存される状態は、そのデータ木構造に貯蔵され、ブロック毎に、その小さな部分木が変更される必要があります。
このようにすると、一般的に、隣り合う二つのブロック間では、木の大部分は同じとなるはずであり、そうであるがゆえ、データは、一度貯蔵され、ポインタ（つまり部分木のハッシュ値）を使用して二度引用符が付加される、という形式をとります。
この「状態」の保存方法を達成するために「パトリシア木」と呼ばれる特別なデータ木が使われ、パトリシア木は、マークル木のコンセプトに対して修正がなされており、ノードの挿入・削除が可能であり、ただ変わるだけでなく、効率が良くなります。
さらに、全状態の情報が、最新のブロックに含まれますので、ブロックチェインの全履歴を保存する必要がありません。
これは、Bitcoinに適用されたら、5-20倍のスペース節約になる技術戦略です。


ひろく尋ねられるのが、「どこでcontractが実行されるのか」という質問で、物理デバイス上でどこか？ということです。
この質問に対しては、シンプルな回答があります。
「contractの実行プロセスは、その状態遷移関数の定義の一部であり、それ故ブロックの有効化アルゴリズムの一部となります。
なので、もしトランザクションがブロックBに付加されたならばそのトランザクションにより生まれるコード実行は全てのノードで実行されます。
その時点より未来において、ブロックBをダウンロードした全てのノードということです。
」

アプリケーション
一般的に、Ethereum上には、3種類のアプリケーションがあります。
一つ目のカテゴリーは、金融系のアプリケーションで、金銭を使用する契約に対し、導入・管理の強力な手段をユーザへ提供するものです。
これには、副次通貨、金融ディリバティブ、ヘッジング契約、預金、資産相続文書や、さらに言及しますと、労働契約書まるまる含めたものなどがあります。
二つ目のカテゴリは、準金融系アプリであり、非金融的事象の結果に対して金銭を絡めてくるようなもので、その良い例として、計算理論における難題に対し懸賞金を自動執行するようなアプリが挙げられます。
三つ目としては、オンライン選挙や分散型統治機構があります。


証明書発行のシステム
ブロックチェイン上の証明書発行システム(tokensystem)には、多々のアプリケーションがあり、USドルや金を表す副次通貨から、株式、スマートプロパティとして個人発行した証明書、堅牢で偽造不可な商品券、あるいは全くの無から新たに作られた貨幣証書でさえその範囲に含まれ、経済原理となる（人々の行動の動機付けとなる）ポイント(稼ぎ)のシステムとして使われます。


Ethereum上で証明書発行システムを実装するのは驚くほどに簡単です。
理解するために重要点は、通貨や証明書システムといった基軸となるものはすべて、あるひとつの操作をともなうデータベースだということです。
そのひとつの操作とは:

AからX単位を差し引き、それをBにやる
その時の条件として
(1)Aはトランザクション以前に少なくともX単位を保持している
(2)トランザクションがAによって承認される
トークンシステムの実装するのにかかる手間は、このロジックをcontractに実装するだけです。
トークンシステムのSerpentにおける実装の基本コードは以下のようになります:

defsend(to,value):
ifself.storage[msg.sender]>=value:
self.storage[msg.sender]=self.storage[msg.sender]-value
self.storage[to]=self.storage[to]+value
これは、基礎的に、このドキュメントの冒頭で説明した"銀行システム"の状態遷移関数の文字通りの実装となります。
このコードとは別に、初期化ステップとして通貨単位を共有するあるいはその他特例のために、数行必要となり、理念としては、あるfunctionは、他のcontractに、あるアドレスの残高を探索してもらうために追加されるものですが、コードの記述はこれで十分です。
理論的に、Ethereum基盤の証明書発行システムで副次通貨としてふるまうものは、潜在的に別の重要な特徴を持っています。
それはBitcoin基盤のmetacurrencyには無いもので、副次通貨で直接トランザクションの手数料の支払いが可能だという機能です。
もしこれを実装すらならば、手数料支払いに使用されるetherを送信者に再振込する方法をとり、contractは、その時のether残高を維持管理することになるかと思います。
手数料支払い時、および常駐のオークションにおいて副次通貨を再度売る時、に使用される、この内部保持されている副次通貨単位を集めることで、etherの残高を再度満たすことになるでしょう。
ユーザはこのためetherでアカウントをアクティベートする必要がありますが、一度etherが確認されると、contractがその度ごとに再度振込をするので、再利用可能となるでしょう。


金融ディリバティブと安定価格通貨
金融ディリバティブは、最も一般的な、smartcontractのアプリケーションであり、コード実装が最も簡単なもののひとつです。
金融契約の実装における主な試練は、その大部分が価格表示器への外部参照が必要となるということです。
例えば、とても望ましいアプリケーションの例として、USドルに対するEther（あるいは別の暗号通貨）の価格変動に対して、リスク回避をおこなうsmartcontractがありますが、これを行うには、ETH/USDの価格がいくらであるかを知るためのcontractが必要となります。
いちばんシンプルな実行方法としては、必要に応じてcontractを更新する能力をもつように設計された(NASDAQの会社組織のような)特定の「パーティ」（利害関係が一致し、結託した参加者の集合、党）により維持管理される「データフィードcontract」を通す方法があります。
これにより、他のcontractはそのデータフィードcontractにメッセージを送信し、価格情報が与えられた返答を受け取ることができます。


それらの重要な材料が与えられているとして,リスク回避contractは次のようになるでしょう:

パーティAが1000ether入金するのを待ちます
パーティBが1000ether入金するのを待ちます
1000etherのUSDでの価値を記録します。
これはデータフィードcontractを探索することで計算され、ストレージに対し、「Xドルだ」と告げます（記録します）
30日後、（データフィードcontractから得られた新しい価格によって計算された）Xドル相当のetherをAに送信し、残りをBに送るのに、AもしくはBが該当contractを再アクティベートすることができるようにします。

このようなcontractには暗号商取引における重要な潜在価値があるでしょう。
暗号通貨を取引等に引用するときに現れる主要な問題として、価格変動が大きいということがあります。
多くのユーザや商売人が暗号資産の取引の安全性や利便性を望んでいるかもしれないにもかかわらず、たった1日で資金の23％を失うという場面には直面したくないでしょう。
この問題に対して、いままでに提案された、最も一般的な解決策としてあるのは、発行者の後ろ盾のある資産です。
この考えは、発行者が発行並びに無効化の権利を有した副次通貨をつくり、金やUSDのような特定の原資産の一単位をオフラインで提供する全ての人に対し、その副次通貨の一単位を提供するというものです。
そして発行者は、その副次資産が送り返されたときには、原資産を提供することを約束します。
この仕組みによって、全ての非暗号化資産が、暗号資産へと"上場"されることが可能となりますが、これは発行主体が信用可能であることにより実現します。


しかし実際は、発行主体は常に信用に価するとは限らず、中には、その銀行システムはあまりにも脆弱であったり、あまりにも顧客対抗的であるようなことが見受けられ、このような金融サービスは実現し難いものとなりえます。
金融ディリバティブはこれに取って代わります。
金融ディリバティブにおいては、資産を裏付ける資金を提供する単一の発行主体の代わりに、分散型の投資市場、つまりETHような基準となる暗号資産の価格が上昇するか賭けをする場所、がその役割を担います。
発行主体とは違って、投資家は自分たちの都合で売り出しをなかったことにすることができません。
というのは、「ヘッジングcontract」がエスクローとして資金を保持しているからです。
この方法でも、まだ完全に非中央集約化したわけではないことに注意してください。
というのは、価格表示器を提供するのに信用あるデータソースが必要となります。
とはいうものの、インフラに対する要求事項を減らし（副次通貨の発行主体となるのとは違って、価格データの発行はライセンスが必要とされず、表現が自由な範疇に分類される可能性が高いのです）、かつ詐欺の可能性を減らした点で大きな進歩と言えます。


IdentityとReputationのシステム
すべての代替暗号通貨のなかでいちばん早くに登場したNamecoinは、名前登録サービスにBitcoinと似たblockchainを用いる試みを行いました。
そこでは、ユーザは他のデータとともに名前を公共的なデータベースに登録することができます。
Namecoinの最も広く普及した利用方法は、DNSシステムとして使う方法で、"bitcoin.org"のような名前を、IPアドレスに対応（mapping)づけたものです。
他の使用方法として、emailauthenticationや、潜在的発展性のあるreputationシステムなどが考えられます。
以下に、Namecoinに似た名前登録システムのEthereum上での、基本contractを示します。


defregister(name,value):
if!self.storage[name]:
self.storage[name]=value
contractはとてもシンプルです。
システムの全容は、追加のみが可能で削除および修正が不可能なEthereumネットワーク内部にあるデータベースです。
誰でも、幾つかの値とともに名前を登録することが可能で、その登録内容は永遠に保管されます。
より洗練された名前登録contractは、他のcontractがその内容を探索できるようにするための関数節（(内部)関数）をもつでしょう。
同様に、（例えば、初期登録者のような）名前の所有者がデータを変更したり所有権を移行したりするためのメカニズムのようなものも考えられます。
reputationやweb上の信用度といった機能性さえ、システムの上層に追加可能です。


分散型ファイルストレージ
過去数年にわたり、オンライン上でのファイルストレージ・サービスのスタートアップが出現し、たくさんの非常に人気あるものが生まれました。
一番人気のあるのが、Dropboxです。
ユーザはハードドライブのバックアップをアップロードし、保管してもらうことが可能で、月額使用料と引き換えにそのデータにアクセスできます。
しかしながら、使用料金支払いの点でファイルストレージの市場は比較的非効率です。
この使用料金問題に関する様々な現存の解決方法を概観しても、"uncannyvalley"と呼ばれる、20-200GBレベルでは、無料利用や企業割引が全く存在せず、ファイルストレージのアクセスに対する月額料金は、同等容量のハードドライブの調達に要する全コストをたった一ヶ月のうちに上回ってしまいます。
Ethereumのcontractによって、分散型ファイルストレージという新しい経済圏を開発することが可能で、そこでは、個人ユーザが自分のハードドライブを貸し出すことで、小遣い稼ぎが可能となり、さらに未使用領域が使用されれば、ファイルストレージのコストは下がります。


そのようなデバイスを裏で繋ぎとめておくための鍵として、"分散型Dropboxcontract"と命名したものがあります。
このcontractは次のように動作します。


まずはじめに、保存したいデータをブロックに分割し、プライバシーのために各ブロックを暗号化し、その暗号化したブロック群から、（データ保管木として）ひとつのマークル木を作り上げます。

Nブロック毎に、contractはマークル木からランダムに参照先を選び、（ランダム性を提供するものとしては直前のブロックハッシュを使用し、contractコードでアクセスできるようにします）、そのデータ木におけるその特定の参照先におけるそのブロックの所有のSPV証明のようなもの（ブロックを預けた人は当然ながら秘密鍵を持っており、その預け人の出すクイズに対して簡潔に回答した証明書）を載せたトランザクションを一番はじめに提供した個人に対して、Xetherを与えます。

ユーザがそれらのファイルを再ダウンロードしたいときは、micropayment　channelプロトコルを使用することができ、（例えば32KBで1szabo支払うといった具合で、)ファイルを復元することできます。
micropaymentchannelを利用した最も支払い効率のよい方法は、支払い者がその終わりまでトランザクションを発行せず、かわりに、そのトランザクションを32KB毎に同じノンスを使用して微量ではあるもののより利益を生むトランザクションに置き換え続けるというやり方です。


この分散型dropboxprotocolの重要な性質として、預け人はたくさんの乱雑なノードがファイルを忘れてしまうという決定をしないものと信用しているように見えるかもしれませんが、秘密共有を通して、ファイルをたくさんの断片へと分割することで、また各断片がどこかのノードに未だに保存されていることを確認するためにcontractを監視することで、そのリスクは限りなくゼロに近づきます。
もし、そのcontractがお金の支払いを続けていたならば、それは、誰かまだファイルを所有している人がいるといった暗号学的証拠を提供していることとなります。


分散型自律組織
分散型自律組織Decentralizedautonomousorganization(DAO)の一般的な概念としては、会員あるいは株主が、67%以上の多数派を占めると、contractコードの修正や、資金の消費が可能となる、仮想団体としてのものです。
会員であれば、まとまることで資金の使い道を決定することができるでしょう。
資金の使い道としては、懸賞金、給料、あるいは、労働報酬として使用価値のある域内通貨のような、異文化地域における仕組みにさえ、適用するこができます。
これは基礎的に、伝統的な会社や非営利組織を合法的にとらえることのできる枠組みでありますが、執行に際し使用するのは、暗号理論に則ったblockchainテクノロジーだけとなります。


DAOの議論をさらに進めると、配当株主や株券をともなう分散型自律株式会社DACorp(decentralizedautonomouscorporation)といった資本主義を推し進めるモデルに行き当たりました。
代案としてある、分散型自律共同体DACom(decentralizdautonomouscommunity)では、会員の除名あるいは入会を承認するといった決定に関し、全会員が平等に権利を保持し、在籍会員の67％の承認を必要とします。
というのは、一人一会員のみという要望があれば、グループによってまとまって執行される必要が有るのです。
（非中央型自動株式会社では、当然大株主が決定権を支配するので、こういった要望は、却下されるでしょう。
）

DAOをコード化する方法の概要は次のようになります。
一番シンプルな設計を示しますと、それは「もし、2/3の会員が賛同すれば、変更する」といった自己修正コードです。
理論的にはcontractコードは不変なものですが、別のところにcontractを複数保持し、ストレージは修正可能なので、そこに呼び出すcontractのアドレスを保持することで、事実として、contractの書き換えが可能となります。
DAOcontractのようなものの簡素な実装において、そのトランザクションが提供するデータによって、三種類に分けることができます。


[0,i,K,V]toregisteraproposalwithindexitochangetheaddressatstorageindexKtovalueV
[0,i]toregisteravoteinfavorofproposali
[2,i]tofinalizeproposaliifenoughvoteshavebeenmade
contractはこれら各種類ごとに、複数の条項を持つでしょう。
contractは、誰が投票したかというリストに従い、全オープンストレージの書き換えを維持管理するでしょう。
さらに、contractは、全会員のリストも保持するでしょう。
どんなストレージの変化も、それが投票する会員の2/3に達したとき、ある最終決定トランザクションがその変化を執行できることとなるでしょう。
より洗練された枠組みとしては、トランザクションの送信、会員の除名や入会のような特徴を組み込んだ投票システムを保持するものもあり、そして流動的民主主義LiquidDemocracyスタイルの代議員議会の投票でさえ提供可能です。
（※誰でも代議員選出が可能で、その選出投票は、遷移的であり、結果、もしAがBを、BがCを選出したならば、CはAの投票権を保持することになります。
）この設計であれば、DAOは分散型コミュニティとして、有機的成長を遂げることが可能で、民衆は結果的に、会員の選出作業を専門家に委任することが可能となります。
しかし、これは"現行の政治システム"にみうけられるようなものとは異なり、個々のコミュニティメンバが提携先を変えることで、時間軸上において、専門家は簡単に出現と消失（取り替え）することが可能です。


代わりとなる分散型株式会社のモデルでは、0以上の株式をもつアカウントがあり、株式の2/3が決定に必要とされます。
完璧な枠組みとしては、財産管理機能や、株式売買の申請機能および受諾機能を備えたものがあるでしょう。
（contract内部に注文一致させる機能があることが望ましいでしょう）代議員選出による委任は、流動的民主主義を存在させ、"意思決定機関"という概念を一般化するものでしょう。


その他のアプリケーション
1.預金ウォレット.次のような場面を考えて下さい。
アリスは、自分の資金を安全に管理したいとします。
しかし彼女は、資産を失うことや秘密鍵がハッキングされることを心配しています。
そこで彼女は、銀行となるボブとともに、contractをつくり、etherをその中に保管します。
それは以下のようになります。


アリスは自分一人で1日あたり最大資金の1%を引き出すことが可能です。

ボブは自分一人で1日あたり最大資金の1%を引き出すことが可能です。
しかし、アリスは自分の秘密鍵でこのボブの能力を奪い去るトランザクションを作成することができます。

アリスとボブは一緒であればどんな額でも引き出し可能です。

通常、1日1％というは、アリスにとって十分な額であり、もしそれ以上引き出したいのであれば、ボブに頼めば済む話となります。
もし、アリスが秘密鍵をハッキングされたならば、アリスは、ボブのところに駆け寄り、ふたりで新しいcontractに資金を移します。
もし、彼女が秘密鍵をなくしてしまえば、結果として、ボブは資金を引き出すことになるでしょう。
もしも、ボブが悪意をもっているとわかったならば、アリスは、ボブの引き出し能力を消去できます。


2.農作物保険.金融ディリバティブcontractは簡単に作成可能ですが、データフィードとして、価格表示器でなく天候を使用します。
アイオワにいる農家が、逆にアイオワにおける降水量を基盤として逆に支払いをするディリバティブを購入したとすると、もし干ばつがあったならば、農家は自動的にお金を受け取り、もし十分な降水があったなら、作物が同様の働きをしてくれるので、農家は幸運を手に入れることができます。
これは一般的に、自然災害の保険にも拡張可能です。


3.分散型データフィード.金融contractその他において、"SchellingCoin"と呼ばれるプロトコルを通してデータフィードを分散化することが実際可能です。
SchellingCoinは基本的に次のように動作します。
N個のパーティが全て、ある与えられた一つのデータ（例えばETH/USDの価格）の値をそれぞれ提供するものとします。
その価格の値はソートされ、その値の順番が25%~75%であるものが、報酬を得られるようにします。
全員が、他の全員が提供するだろう答えを提供するインセンティブを保持し、その大多数のプレイヤが現実的に認める唯一の価格が、明白な基準となり、これは信用のおけるものとなります。
これによって、理論的にどんな数値をも提供することが可能な、分散型プロトコルが作られます。
それには、ETH/USD価格、ベルリンの気温、あるいは特定の重い計算の結果、でさえ含まれます。


4.スマート・マルチシグネチャ認証.Bitcoinではマルチシグネチャ・トランザクションcontactが可能で、例えば、５つの秘密鍵のうち、３つが揃えば資金を使用できるといったものです。
Ethereumでは、より詳細な設計が可能です。
たとえば、５つのうち４つで全て使用可能とし、５つのうち３つで1日10%使用可能とし、５つのうち２つで1日0.5%使用可能とすることができます。
加えて、Ethereumマルチシグネチャは同期します。
というのは二つのパーティが、別々の時間にblockchain上に署名を登録することが可能で、その最後の署名が行われれば、自動的にトランザクションは送信されます。


5.クラウド・コンピューティング.EVMテクノロジは、検証可能な計算環境を構築する目的でも使用され、ユーザは他人に対して、計算の実行を依頼することができます。
またオプションとしてランダムに選択したチェックポイントにおける、計算の整合性を示した証拠の提出を依頼することができます。
これによって、クラウド・コンピューティングの市場を作ることが可能で、どんなユーザでも、デスクトップ型あるいはノートパソコンあるいは特化型サーバを用いて参加することが可能です。
そして、セキュリティ課金を用いたスポットチェックにより、システムが信用に足るかということを確かめます。
（結果ノードはチートすることによって、より利益を得ることはできません。
）このようなシステムは、あらゆるタスクに適する、ということはないかもしれません。
たとえば、内部プロセスにおける高度な連携が必要なタスクだと複数のノードによる大きなクラウドにおいて、簡単に計算することは不可能です。
しかしながら、他のタスクは容易に並列化可能で、SETI@home、folding@homeや遺伝的アルゴリズムのようなプロジェクトは簡単に、プラットフォーム上に構築可能です。


6.P2P賭博.P2P賭博プロトコルはいくらでも実装可能で、例えば、FrankStajanoとRichardClaytonによるCyberdiceはEthereumblockchain上で実装できます。
簡素な賭博プロトコルは実はただの次のブロックのハッシュ値を当てるだけのcontractで、より進化したプロトコルはそこから作り上げることが可能で、チート不可能な手数料が０に近い賭博サービスを作ることができます。


7.市場予測.SchellingCoinあるいはOracleが提供されることで、市場予測もまた実装が容易となります。
市場予測とSchellingCoinが一緒になることで、非中央組織の統治プロトコルであるfutarchyの主流アプリケーションとしては初のものと成る可能性があります。


8.blockchain上の商取引市場,IdentityとReputationのシステムを基盤とします。


雑録と関心事
GHOSTの修正実装
GreedyHeavistObservedSubtree(GHOST)は、YonatanSompolinskyとAvivZoharによって2013年12月に初めて導入されたイノベーションです。
GHOST開発の動機は、blockchainの検証時間を短縮すると、現行のシステムでは、「非同期状態」（最新のブロックと同期していない状態）の割合が増えるため、セキュリティを減少させてしまうという問題に苦しんでいます。
というのは、ブロックはネットワークを通して伝播するのにある程度の時間がかかるため、もし、マイナーAがブロックを発掘し、つぎにマイナーBがたまたまAのブロックがBに伝わってくる前にその他のブロックを見つけた場合、マイナーBのブロックは最終的に無駄となり、ネットワークセキュリティに貢献しないこととなります。
さらには中央集約の問題があります。
それは、もしマイナーAが30%の採掘能力を持つマイニングプールで、Bが10%の採掘能力を持つものとすると、Aには、採掘時間の70%は無効なブロックを生成するリスクがあり、（採掘時間の30%のあいだ、Aは有効な最終ブロックを生成しているということなので、採掘データをすぐに得る事ができます。
）一方、Bには、採掘時間の90%は無効なブロックを生成するリスクがあります。
このよう状況で、ブロック生成の間隔が「非同期状態」の割合が高くなるぐらいに十分、ブロック間のインターバルが短いと、Aは、単に自身のプールのサイズから得られる効能によって、実質上さらに効率的となります。
これら二つの効果が結びつくことで、ブロック生成の速いブロックチェーンは、ネットワーク上の採掘能力のうち大きな割合を占めやすくなり、マイニングのプロセス全体をコントロールできるマイニングプールを生み出してしまいます。


SomopolinskyとZoharの説明によると、GHOSTは、最長チェインの計算上において、無効ブロックを採り入れることで、一つ目のネットワークセキュリティ損失の問題を解決します。
つまり、親ブロックや先祖ブロックのみでなく、proof-of-workの裏付けされネットワーク上で最長チェインを誇る、先祖ブロックの無効な子孫ブロック(ethereum用語では「uncle(叔父)」)が計算に加えられます。
二つ目の中央集約のバイアスがかかるという問題を解決するためには、SomopolinskyとZoharによって描かれたプロトコルのさらに先を考える必要があり、無効ブロックへの報酬を供給する必要があります。
無効ブロックは元となる報酬の87.5%を受け取り、uncleとして無効ブロックを採り入れたnephew(甥)ブロックには残りの12.5%が贈られます。
しかしながら、トランザクション手数料はuncleには与えられません。


Ethereumは、７層だけ遡る簡易版GHOSTを実装しました。
仕様としては以下の通りです。


Ablockmustspecifyaparent,anditmustspecify0ormoreuncles
AnuncleincludedinblockBmusthavethefollowingproperties:
ItmustbeadirectchildofthekthgenerationancestorofB,where2<=k<=7.
ItcannotbeanancestorofB
Anunclemustbeavalidblockheader,butdoesnotneedtobeapreviouslyverifiedorevenvalidblock
Anunclemustbedifferentfromallunclesincludedinpreviousblocksandallotherunclesincludedinthesameblock(non-double-inclusion)
ForeveryuncleUinblockB,theminerofBgetsanadditional3.125%addedtoitscoinbaserewardandtheminerofUgets93.75%ofastandardcoinbasereward.
この制限版のGHOSTでは、７世代上までのuncleを取り込みますが、これが採択されたのには２つの理由がありました。
ひとつめとして、無制限のGHOSTだと、与えられたブロックに対し、どのuncleが有効なのか確かめる計算が複雑になりすぎます。
ふたつめとして、無制限のGHOSTとEthereumで使用されている報酬の方法が合わさると、採掘者が、メインチェイン上で採掘する動機を取り去ってしまい、攻撃者のチェインにおいてはそうでないので、攻撃されすくなります。


手数料
blockchain上に発行される全トランザクションは、ネットワークに対し、ダウンロードと検証に際し必要なコストの支払いを強いるので、乱用を防ぐために、トランザクション手数料に代表される、何らかの規制メカニズムが必要となります。


Bitcoinでとられている初期のアプローチでは、純粋な寄付金としての手数料をとり、採掘者に対し、「門番」の役割と動的な最小額を決める役割を依頼しています。
このアプローチはBitcoinコミュニティには好意的に受け入れられました。
これには、採掘者とトランザクション送信者間の需給バランスにより価格が決まる、といった市場原理に基づくという理由があります。
しかしながら、この論理の道筋には問題があって、トランザクションの処理は市場ではないのです。
というのは、トランザクションを採掘者が送信者にオファするサービスと捉えることには本質的魅力がありますが、実際は、採掘者が採り入れた全トランザクションは、ネットワーク内の全てのノードにおいて処理される必要があるため、トランザクション実行のための大きなコストはサードパーティによって担われ、あるトランザクションを取り入れるかどうかの決定は採掘者に担われている訳ではないのです。
このような仕組みでは、コモンズの悲劇の問題が発生する確率が非常に高いのです。


市場原理に基づくメカニズムにおけるこの欠陥が明るみにでましたが、ある特定の厳密でないシンプルな仮定のもとで、その欠陥を手品のようにキャンセルすることができます。
論拠は以下のようなものです。


k個のオペレーションを含むトランザクションに対して、送信者がそのオペレーションを含める採掘者に対してkRの報酬をオファーする。
ここで、Rは送信者によって決定され、kとRは採掘者に対しておおよその値が事前に分かるようにする。

一つのオペレーションはどのノードにとってもCという実行コストを持つ（すなわち、すべてのノードは同じ効率をもつ）
N個のマイニングノードが存在するとき、それぞれは全く同じ処理能力を持っている（すなわち1/Nである）
採掘をしないフルノードは存在しない
採掘者は、期待できる報酬がコストより大きければ、トランザクションを喜んで処理します。
そして、採掘者が次のブロックを見つける確率は1/Nなので、予想される報酬はkR/Nとなり、採掘者にとっての処理コストはkCだけです。
このように考えると、採掘者はkR/N>kCつまりR>NCの時、トランザクションを取り込みます。
ここで、Rは送信者がオペレーション処理の前に支払う手数料で、送信者がトランザクション送信による利益を享受するのに必要な最低料金となります。
NCはオペレーションを処理するためのネットワーク全体のコストであり、よって、採掘者は、実利のトータルがコストを超えるトランザクションだけを取り入れようとします。


しかし、実際の仮定では、いくつか重要な逸脱が生じます。


採掘者は実際には他の検証ノードよりもトランザクション処理に高いコストを払う事があります。
それは、追加の検証時間がブロックの伝搬を遅らせ、ブロックが無効になる可能性が増加するためです。

採掘を全くしないフルノードが存在します。

現実には採掘能力の分散は非常に不平等なものとなります。

投機家、政敵、ネットワークの存在に対して攻撃を仕掛ける道具をもった狂人が存在しまう。
彼らは頭が良く、contractにおいて、自分たちのコストが他の検証ノードが払うコストよりもかなり低いような環境を設定します。

(1)は採掘者が少ししかトランザクションを取り込まない傾向を生み出してしまいます。
(2)はNCを増加させます。
よって、(1)と(2)は、少なくとも互いに部分的にキャンセルします。
(3)(4)は重要な問題です。
これらの問題を解決する方法としては、単純に上限を設定しました。
どのブロックもBLK_LIMIT_FACTOR回x長期指数関数移動平均以上のオペレーションを行うことはできません。
つまり、

blk.oplimit=floor((blk.parent.oplimit*(EMAFACTOR-1)+floor(parent.opcount*BLK_LIMIT_FACTOR))/EMA_FACTOR)
BLK_LIMIT_FACTORとEMA_FACTORは、当分は、65536と1.5に設定される定数で、さらに解析が進めば、変更される可能性があります。


Bitcoinに見られる大きなブロックを推奨しない別の理由として、大きなブロックは伝播するのに、時間がかかります。
そして、このように、高確率で新鮮でないものとなってしまいます。
Ethereumにおいては、ガス消費量の大きいブロックも同様に伝播するのに時間がかかります。
それには、物理的に大きいトランザクションの状態遷移を検証するのに時間が掛かるという双方の理由があります。
この遅延がゆえの非推奨はBitcoinにおいては重要な問題ですが、Ethereumにおいては、GHOSTプロトコルのおかげでそれほど問題ではありません。
このように、ブロックを規制することにより、より安定した基盤工程ができあがります。


計算とチューリング完全
Ethereum仮想マシンがチューリング完全だというのはとても重要なことです。
これは、EVMコードが無限ループを含む計算もコード化できることを意味します。
EVMコードは二つの方法でループを可能にします。
第一に、JUMP命令はプログラムにコードの以前のどこか指定した場所へジャンプします。
JUMPI命令はwhilex<27;x=x*2のような条件分岐を可能にします。
第二にcontractは別のcontractを呼ぶ事ができ、潜在的に再帰によりループが可能となります。
この方法では当然問題に行き当たります。
悪意をもったユーザは、無限ループに陥らせる事で採掘者を黙らせ、フルノードをダウンさせることができるのか？という問題で、これは、コンピュータサイエンスの「実行停止問題」として知られる問題を浮かび上がらせます。
実行停止問題とは、一般的に与えられたプログラムがいつまでも停止しないかどうかを知る方法が無いというものです。


"状態遷移の章"で説明したように我々の解決方法は、トランザクションに対し、許される最大の計算ステップ数を設定し、もし実行が長引けば計算を元に戻し、費用だけを支払うといったもので、メッセージも同じ方法をとります。
我々がこの解法を選んだ動機を理解するために、以下のような例を考えてみましょう。


攻撃者が、無限ループを引き起こすcontractを作り、採掘者に対してそのループを引き起こすトランザクションを送信します。
採掘者はトランザクションを実行し、無限ループを実行し、そして燃料が切れるのを待ちます。
実行は燃料切れになり、途中で止まりますが、トランザクションはまだ有効であり、採掘者は各実行ステップのための手数料を攻撃者に要求し続けています。

攻撃者は非常に長い無限ループを作り、数ブロックが認証されるほどの時間、採掘者を計算させ続け、採掘者がトランザクションを含めて手数料を要求することを不可能にさせます。
しかし、攻撃者は計算ステップ数の上限を決めるSTARTGASの値を提供する必要があるので、採掘者は計算が非常に大きなステップ数であることを前もって知ります。

攻撃者はsend(A,contract.storage[A]);contract.storage[A]=0のようなコードを持ったcontractを見て、最初のステップのみ実行できて二番目のステップは実行できないような量の燃料を持ったトランザクションを送付します。
（つまり、引き出しはするが差額を減らさせない）。
contractの作者はそのような攻撃に対する防御を考える必要はない。
なぜならば、実行が途中で終わる時には状態の変化は元に戻ります。

ある金融contractがリスクを減らすために９つの固有のデータフィードの中央値をとるとします。
DAOの章で説明したような、呼出アドレスを変数化するメカニズムを通して変更可能な設計をされている一つのデータフィードを攻撃者は乗っ取り、無限ループを引き起こすように変更し、金融contractから資金を要求するものを燃料切れにしていきます。
しかしながら、金融contractは、メッセージ上で燃料の上限を設定できるので、このような問題は防ぐ事ができます。

チューリング完全に取って代わるものは、チューリング不完全です。
JUMPやJUMPI命令は存在せず、コールスタックにはそれぞれのcontractの一つだけのコピーが存在できます。
このシステムではこれまでに述べた手数料システムや我々の解決策の効果についての不確実性は必要なくなります。
なぜならcontractを実行するコストはそのサイズによって上限が決まるからです。
さらに、チューリング不完全はそれほど大きな制約ではありません。
というのは、我々が内部で想像した全てのcontractの例で、一つのみがループを必要とし、さらにそのループはコードを26回繰り返す事によって取り除くことができました。
チューリング完全のもたらす厳しさや限定された利益を考えた時、何故チューリング不完全な言語を使用しないのでしょうか？しかし実際は、チューリング不完全では、与えられた問題の正しい解決からはほど遠いものです。
その理由を知るために、以下のcontractを考えましょう。


C0:call(C1);call(C1);
C1:call(C2);call(C2);
C2:call(C3);call(C3);
...
C49:call(C50);call(C50);
C50:(runonestepofaprogramandrecordthechangeinstorage)
いまあるトランザクションをAに送ります。
このように、51個のトランザクションにおいて、250の計算ステップを持つcontractを保持するものとします。
採掘者はそれぞれのcontractに付随する、最大の計算ステップ数や、contractが呼出すcontractを前もって見る事によってそのような論理爆弾を事前に察知することが可能ですが、これには、採掘者が他のcontractを作り出すcontractを禁止する必要が有ります。
(なぜなら、上記の51個のcontractの生成と実行は簡単に一つのcontractに書き記すことができるのです。
）他の問題となるポイントはメッセージのアドレスフィールドが変数であり、一般的にcontractが呼出す他のcontractを事前に理解することが不可能なことです。
よって、我々は驚くべき結論を得ます。
チューリング完全では驚く程容易に管理でき、一方、チューリング不完全では、チューリング完全と同じ機能を持たせようとすると、驚く程管理が難しくなります。
そのような場合、チューリング完全にしない理由はありません。


通貨と発行
Ethereumネットワークは、ネットワークに組み見込まれた自身の通貨Etherを持っています。
この通貨は二つの目的で使われます。
一つ目は、多様なデジタル資産間の効率的な交換を可能にする、基本的な流動性レイヤーを提供する事です。
二つ目はより重要ですが、トランザクションフィーを支払うメカニズムを提供する事です。
話を簡単にするため、また今後の議論を避けるため(BitcoinにおけるmBTC/uBTC/satoshiに関する現在の議論を参照してください)、通貨の単位は予め決まっている予定です。


1:wei
1012:szabo
1015:finney
1018:ether
これは、"ドルとセント"、あるいは"BTCとsatoshi"の概念を広げたものと考えられるはずです。
近い将来、etherは通常のトランザクションで使用され、finneyはマイクロトランザクションで使用され、szaboとweiは手数料やプロトコル実装のテクニカルな議論で用いられると予想しています。
他の単位は、今後役立つ事として、現時点では、クライアントで利用するべきではないでしょう。


Ether発行のモデルは以下の通りです。


Etherは1BTCあたり1000-2000etherで、プリセールにて公開される予定です。
これは、EthereumOrganizationの資金調達と開発資金の調達を目的としており、MastercoinやNXTのような他プラットフォームでも使われ、成功している方法です。
より早く購入した人はより大きなディスカウントを得る事ができるでしょう。
プリセールで得られたBTCは、全て、開発者の給与や報奨金の支払いに使われます。
また、Ethereumや仮想通貨エコシステム内の、様々な営利または非営利プロジェクトへの投資に使用されます。

0.099xプリセール総販売額(60,102,216ETH)は、EthereumOrganizationへ割り当てられ、初期に貢献した人達への報奨金と、ジェネシスブロック生成開始前のETH建て経費の支払いに利用されます。

0.099xプリセール総販売額は、長期準備金として維持管理されます。

0.26xプリセール販売額は、それ以降ずっと、1年毎にマイナーへ割り当てられます。

Group	Atlaunch	After1year	After5years
Currencyunits	1.198X	1.458X	2.498X
Purchasers	83.5%	68.6%	40.0%
Reservespentpre-sale	8.26%	6.79%	3.96%
Reserveusedpost-sale	8.26%	6.79%	3.96%
Miners	0%	17.8%	52.0%
長期的な供給量の成長率(パーセント)

SPVinbitcoin

通貨発行量は線形増加するが、Bitcoinと同様、長期的には供給量の成長率はゼロに収束してゆく

上記モデルの主な特徴は、(1)基金プールとその規模、(2)Bitcoinにおける"供給量上限ありモデル"とは対照的な"供給量成長モデル"、の二つです。


基金プールが正当である理由は次のとおりです。
もし基金プールが存在せず、同じインフレ率を実現するために発行量を0.217倍に減少させたとすると、etherの全供給量は16.5%減り、ether1単位の価値は19.8%上昇するでしょう。
従って、均衡を成立させるなら、19.8%多くのetherがセールで購入されれば、1単位が再び以前と全く同じ価値を持つことになるでしょう。
EthereumOrganizationは、1.198倍のBTCを持つことになりますが、これは、オリジナルのBTCと追加の0.198xのBTCの二つに分ける事ができます。
従って、この基金プールなしの状況は、基金プールがある状況と完全に等価ですが、一つだけ重要な違いがあります。
それは、EthereumOrganizationが純粋にBTCを保持しており、etherの価値を維持するインセンティブを持たないという事です。


"供給量成長モデル"は、Bitcoinにおける富の集中リスクを減らします。
そして、現在および今後、個人に公平な通貨の獲得機会を与えます。
同時に、"サプライ成長率"はゼロに収束していくため、Etherを得て保持しようという強いインセンティブを維持します。
また次のような理論化ができます。
コインは、不注意、死、その他の理由で時と共に失われており、コインの消失は一年あたりの総供給量に対する割合としてモデル化できます。
そして、全通貨供給量は、年間発行量を消失率で割った値に落ち着きます。
（例えば、損失率が1%の場合、供給量が26Xに到達すると、0.26Xがマイニングされて、0.26Xが毎年失われるので、均衡状態が成立します)。


将来、Ethereumはセキュリティのためproofofstakeモデルに切り替える可能性が高いことに留意してください。
これにより、発行量の必要条件は年間0から0.05Xの水準に減ります。
EthereumOrganizationが資金を失ったり、他の理由で消滅した場合に備えて、"socialcontract"を残します。
誰もが次世代版のEthereumを作る権利があり、唯一の条件はetherの総額が最大で60102216*(1.198+0.26*n)(n:ブロック生成開始からの年数)に等しくなければならないという事だけです。
クリエイターは開発費用を捻出するために、自由にクラウドセールを行ったり、PoSによる供給拡大と供給拡大の上限との差の一部または全てを自由に使用することができます。
socailcontractに準拠しないアップグレード版の候補は、準拠版として公正にフォークされる可能性もあります。


マイニング集中
Bitcoinのマイニングアルゴリズムは、毎回少しずつ異なるブロックヘッダー上で、マイナーにSHA256の演算を何百万回も繰り返し、最終的に一つのノードがあるターゲット（現在は2192)以下のハッシュ値を見つけるまで、計算させることで機能しています。
しかし、このマイニングアルゴリズムは、二種類の一極集中に対する脆弱性を持っています。
一つは、マイニングのエコシステムが、Bitcoinマイニングのタスク用にデザインされ、数千倍の効率を持つASIC(application-specificintegratedcircuits)に支配されるようになってきているという事です。
つまり、Bitcoinのマイニングは、もはや分散化されているわけでも平等を追求しているわけでもありません。
マイニングに参加して報酬を得ようとするなら、数百万ドルが必要になります。
第二に、殆どのBitcoinマイナーはブロックの検証プロセスを実際はローカルでは行っていません。
その代わり、ブロックヘッダを供給するために、一極集中したマイニングプールに依存しています。
この問題は、おそらくもっとひどいものです。
この文章を書いている時点で、トップ３のマイニングプールが、間接的にBitcoinネットワークの約50%の計算パワーをコントロールしています。
(もし、あるマイニングプールや結託したマイニングプールが51%攻撃をしようとした場合、マイナーは他のマイニングプールへ移る事でこの状況は緩和はできるけれども)

現在Ethereumが使用しようとしているアルゴリズムでは、マイナーは、ブロックチェーンの「状態」をもとにランダムなデータを作り出し、ブロックチェインの最後のNブロックからランダムに選ばれたトランザクションを計算し、結果のハッシュを返す事が要求されます。
これは二つの重要な利点があります。
第一に、Ethereumのcontractはどのような種類の演算も取り込む事ができるため、Ethereum用のASICは汎用的な計算用のASICになるでしょうーすなわち、より良いCPUです。
第二に、マイニングが、完全なブロックチェインへのアクセスを要求します。
その結果、マイナーに、完全なブロックチェインの保持、そして少なくとも全てのトランザクションが検証できることを強制します。
これは一極集中したマイニングプールの必要性を取り除くことになります。
マイニングプールは、報酬分配の確率を平準化する役割を果たしていますが、このマイニングプールの機能は、P2Pプールによって中央的な管理無しで、同じくらい上手く実現できます。


このモデルはまだテストされていません。
そしてマイニングアルゴリズムとしてcontractを実行する時、途中で巧妙な最適化を避けるのは困難かもしれません。
しかし、このアルゴリズムの面白い特徴の一つは、大量のcontractを、ある種類のASICを妨害するよう特別に設計されたブロックチェインに導入する事で、誰でも井戸に毒を盛る事ができるということです。
ASIC製造者にはお互いにそのようなトリックを使って攻撃する経済的なインセンティブが存在します。
よって、我々が開発中のソリューションは、純粋なテクニカルなものというよりも、突き詰めると経済的、人間的なものです。


スケーラビリティ
Ethereumに関するよくある懸念点の一つは、スケーラビリティの問題です。
Bitcoinのように、Ethereumでは「全てのトランザクションがネットワーク上の全てのノードで実行される必要がある」という欠点があります。
Bitcoinの現在のブロックチェインのサイズは約15GBであり、一時間ごとに1MB増加しています。
もしBitcoinネットワークがVisaのように一秒当たり2000トランザクションを処理するとした場合、3秒当たり1MB(１時間あたり1GB,一年当たり8TB)増加することになります。
Ethereumも同じ成長パターンを経験するでしょう。
Bitcoinのようなただの通貨とは異なり、Ethereumブロックチェイン上に様々なアプリケーションが存在するという事は、この成長パターンを悪化させるでしょう。
しかし、Ethereumのフルノードは、ブロックチェインの全ての履歴に代わり、状態だけを保持すれば良いという事は、この成長パターンを改善するでしょう。


このような巨大なブロックチェインサイズに関する問題は、中央集権化のリスクです。
仮にブロックチェインのサイズが100TBになったとします。
このとき想定されるのは、非常に少数の大企業がフルノードを稼働させる一方、通常のユーザーはライトなSPVノードを使うというシナリオです。
そのような状況では、フルノードが、利益を得るために結託して不正行為に合意するかもしれないという、潜在的な懸念が発生します。
（例えば、ブロック報酬を変更する、自分達にBTCを与える、など)。
ライトノードは、これを即座に検知する方法がありません。
もちろん、少なくとも一つは正直なフルノードが存在するでしょうし、数時間後には、不正行為に関する情報は、Redditのようなチャンネルを通じて広まるでしょう。
しかし、その時点ではもう遅すぎるのです。
つまり、与えられたブロックをブラックリストに載せるかどうかは一般ユーザに委ねられており、51％攻撃を摘み取るのと同規模な、大規模かつおそらくは実行不可能な調整の問題なのです。
Bitcoinの場合、このことは現在問題になっています。
しかしPeterToddの提案がこの問題を緩和するでしょう。


近い将来、Ethereumはこの問題に対処するため、さらなる二つの対策を採用する予定です。
第一に、ブロックチェインベースのマイニングアルゴリズムなので、すくなくとも全てのマイナーがフルノードになる事を強制します。
その結果、フルノード数の下限ができます。
第二に、さらに重要なのは、各トランザクションを処理した後、ブロックチェイン内部に中間状態木ルートを含めます。
たとえ、ブロックの検証が中央集権化したとしても、一つの正直な認証ノードが存在する限り、中央集権問題は検証プロトコルにより回避可能です。
もし、あるマイナーが無効なブロックを発行した場合、そのブロックはフォーマットが間違っているか、もしくは状態S[n]が正しくないか、の何れかに違いありません。
S[0]は正しい事が分かっているので、どこかにS[i-1]は正しいが、S[i]は正しくないという最初の状態が存在しなければいけません。
検証ノードは、APPLY(S[i-1],TX[i])->S[i]を処理するのに必要なパトリシア木ノードのサブセットから構成される"無効証明"と共に、インデックスiを提供します。
ノードは、これらの検証ノードを、演算の一部として実行したり、与えられたS[i]と生成されたS[i]がマッチしない事を確かめたりするのに利用できるでしょう。


もう一つのより洗練された攻撃は、悪意のあるマイナーによる不完全なブロックの発行です。
これにより、ブロックが有効かどうかを決定するのに、十分な情報が存在しないことになります。
この攻撃に対する解決策はchallenge-responseプロトコルです。
つまり、検証ノードは、ターゲットとなるトランザクションのインデックスの形式で「challenge」を発行します。
そして、軽量ノードは、あるノードを受け付けると、(マイナーか検証ノードかに関わらず)別のノードが有効証明としてのパトリシアノードの部分集合を提供するまで、ブロックを信用できないものとして扱います。


結論
Ethereumプロトコルは、元々は、アップグレード版の暗号通貨と考えられていました。
ブロックチェイン上で、エスクロー、引き出し上限、金融コントラクト、ギャンブルマーケットといった進んだ機能を、高度に一般化されたプログラミング言語を通して提供する暗号通貨です。
Ethereumのプロトコルはどんなアプリケーションも直接にはサポートせず、チューリング完全なプログラミング言語のみが存在します。
それは、理論的には、どのようなトランザクションやアプリケーションに対しても、任意のコントラクトを作れるということです。
しかし、Ethereumについて、さらに興味深い事は、Ethereumのプロトコルは単なる通貨を超えているということです。


分散型ファイルストレージ、分散型コンピューティング、および分散型予想市場に関するプロトコルは、その他多くのアイデイアの中でも特に、計算の効率を飛躍的に向上させる可能性があります。
そして、その他のP2Pプロトコルを、経済レイヤーを加えることにより、強力に後押しします。
最終的には、お金とは全く関係のない数々のアプリケーションが現れるでしょう。


Ethereumプロトコルによって実装された状態遷移関数のコンセプトは、ユニークな可能性を持ったプラットフォームです。
Ethereumは、データストレージ、ギャンブル、金融などの特定のアプリケーションを意図したクローズドで単一の目的を持つプロトコルではなく、オープンな設計になっています。
我々は、Ethereumが、今後の金融および非金融の多くのプロトコルの基礎レイヤーとして、非常に適したものであると信じています。

