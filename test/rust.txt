#https://doc.rust-jp.rs/the-rust-programming-language-ja/1.6/book/variable-bindings.html
変数束縛
事実上全ての「Hello World」でないRustのプログラムは 変数束縛 を使っています。
変数束縛は何らかの値を名前へと束縛するので、後でその値を使えます。
このように、 let が束縛を導入するのに使われています。
訳注: 普通、束縛というときは名前 を 値 へ と束縛しますが、このドキュメントでは逆になっています。
Rustでは他の言語と違って1つの値に対して1つの名前が対応するのであえてこう書いてるのかもしれません。
例で毎回 fn main() { と書くのは長ったらしいのでこれ以後は省略します。
もし試しながら読んでいるのならそのまま書くのではなくちゃんと main() 関数の中身を編集するようにしてください。
そうしないとエラーになります。

パターン
多くの言語では変数束縛は 変数 と呼ばれるでしょうが、Rustの変数束縛は多少皮を被せてあります。
例えば、 let の左側の式は「パターン」であって、ただの変数名ではありません。
これはこのようなことが出来るということです。

パターン式が評価されたあと、 x は1になり、 y は2になります。
パターンは本当に強力で、本書にはパターンのセクションもあります。
今のところこの機能は必要ないので頭の片隅に留めておいてだけいて下さい。

型アノテーション
Rustは静的な型付言語であり、前もって型を与えておいて、それがコンパイル時に検査されます。
じゃあなぜ最初の例はコンパイルが通るのでしょう?
ええと、Rustには「型推論」と呼ばれるものがあります。
型推論が型が何であるか判断出来るなら、型を書く必要はなくなります。

書きたいなら型を書くことも出来ます。
型はコロン(:)のあとに書きます。

これをクラスのみんなに聞こえるように声に出して読むなら、「 x は型 i32 を持つ束縛で、値は 五 である。」となります。

この場合 x を32bit符号付き整数として表現することを選びました。
Rustには多くのプリミティブな整数型があります。
プリミティブな整数型は符号付き型は i 、符号無し型は u から始まります。
整数型として可能なサイズは8、16、32、64ビットです。

以後の例では型はコメントで注釈することにします。
先の例はこのようになります。

この注釈と let の時に使う記法の類似性に留意して下さい。
このようなコメントを書くのはRust的ではありませんが、時折理解の手助けのためにRustが推論する型をコメントで注釈します。

可変性
デフォルトで、 束縛は イミュータブル です。
このコードのコンパイルは通りません。

次のようなエラーが出ます。
訳注: エラー: イミュータブルな変数 `x` に再代入しています

束縛をミュータブルにしたいなら、mutが使えます。

束縛がデフォルトでイミュータブルであるのは複合的な理由によるものですが、Rustの主要な焦点、安全性の一環だと考えることが出来ます。
もし mut を忘れたらコンパイラが捕捉して、変更するつもりでなかったものを変更した旨を教えてくれます。
束縛がデフォルトでミュータブルだったらコンパイラはこれを捕捉できません。
もし 本当に 変更を意図していたのなら話は簡単です。
mut をつけ加えればいいのです。

可能な時にはミュータブルを避けた方が良い理由は他にもあるのですがそれはこのガイドの範囲を越えています。
一般に、明示的な変更は避けられることが多いのでRustでもそうした方が良いのです。
しかし変更が本当に必要なこともあるという意味で、厳禁という訳ではないのです。

束縛を初期化する
// Rustの束縛はもう1つ他の言語と異る点があります。
Rustの束縛はもう1つ他の言語と異なる点があります。
束縛を使う前に値で初期化されている必要があるのです。

試してみましょう。
src/main.rs をいじってこのようにしてみて下さい。

コマンドラインで cargo build を使ってビルド出来ます。
警告が出ますが、それでもまだ「Hello, world!」は印字されます。

Rustは一度も使われない変数について警告を出しますが、一度も使われないので人畜無害です。
ところがこの x を使おうとすると事は一変します。
やってみましょう。
プログラムをこのように変更して下さい。

そしてビルドしてみて下さい。
このようなエラーが出る筈です。

Rustでは未初期化の値を使うことは許されていません。
次に、 println! に追加したものについて話しましょう。

印字する文字列に2つの波括弧{}、口髭という人もいます。
訳注: 海外の顔文字は横になっているので首を傾けて { を眺めてみて下さい。
// また、日本語だと「中括弧」と呼ぶ人もいますね))を入れました。
Rustはこれを何かの値を入れて(interpolate、インターポーレート)くれという要求だと解釈します。
 文字列インターポーレーション (String interpolation)はコンピュータサイエンスの用語で、「文字列の中に差し込む」という意味です。
 その後に続けてカンマ、そして x を置いて x がインターポーレートしようとしている値だと指示しています。
 カンマは2つ以上の引数を関数やマクロに渡す時に使われます。

単に波括弧だけを使った時は、Rustはインターポーレートされる値の型を調べて意味のある方法で表示しようとします。
フォーマットをさらに詳しく指定したいなら数多くのオプションが利用出来ます。
とりあえずのところ、デフォルトに従いましょう。
整数の印字はそれほど複雑ではありません。

スコープとシャドーイング
束縛に話を戻しましょう。
変数束縛にはスコープがあります。
変数束縛は定義されたブロック内でしか有効でありません。
ブロックは { と } に囲まれた文の集まりです。
関数定義もブロックです!
以下の例では異なるブロックで有効な2つの変数束縛、 x と y を定義しています。
x は fn main() {} ブロックの中でアクセス可能ですが、 y は内側のブロックからのみアクセス出来ます。

最初の println! は「The value of x is 17 and the value of y is 3」(訳注: 「xの値は17でyの値は3」)と印字する筈ですが、2つめの println! は y がもうスコープにいないため y にアクセス出来ないのでこの例はコンパイル出来ません。
代わりに以下のようなエラーが出ます。

さらに加えて、変数束縛は覆い隠すことが出来ます
訳注: このことをシャドーイングと言います。
つまり後に出てくる同じ名前の変数束縛があるとそれがスコープに入り、以前の束縛を上書きするのです。
シャドーイングとミュータブルな束縛はコインの表と裏のように見えるかもしれませんが、それぞれ独立な概念であり互いに代用が出来ないケースがあります。
その1つにシャドーイングは同じ名前に違う型の値を再束縛することが出来ます。
